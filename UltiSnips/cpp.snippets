extends c

snippet std
	std::${1:for_each}(${2:ctn}${3:.}begin(),
	$2$3end(),[&](decltype(*$2$3begin()) ${4:v}) {
		${0}
	});
endsnippet

snippet stdi
	std::${1:for_each}(${2:first}, ${3:last}(),[&](decltype(*$2) ${4:v}) {
		${0}
	});
endsnippet

snippet tpc
template<class ${1:T}>
endsnippet

snippet tpt
template<typename ${1:T}>
endsnippet

snippet forz
for (${1:size_t} ${2:i} = 0; $2 < ${3:size}; ++$2) {
	${0}
}
endsnippet

snippet forui
for (${1:unsigned int} ${2:i} = 0; $2 < ${3:size}; ++$2) {
	${0}
}
endsnippet

snippet forgu
for (GLuint ${1:i} = 0; $1 < ${2:size}; ++$1) {
	${0}
}
endsnippet

snippet forit
	for(${1:std::vector<T>::iterator} iter = ${2:ctn.}begin(); iter !=
	${2}end(); ++iter){
		${0}
	}
endsnippet

snippet box0
//==============================================================================
//${0}
//==============================================================================
endsnippet

snippet box1
//------------------------------------------------------------------------------
//${0}
//------------------------------------------------------------------------------
endsnippet

snippet onew
osg::ref_ptr<${1}> ${2} = new $1(${3});
endsnippet

snippet osgDemo
#include <osgViewer/Viewer>
#include <osgViewer/ViewerEventHandlers>
#include <osg/Geometry>
#include <osgDB/ReadFile>
#include <osg/MatrixTransform>

int main(int argc, char* argv[]) {
	${0}
	osgViewer::Viewer viewer;
	viewer.addEventHandler(new osgViewer::StatsHandler);
	//viewer.setSceneData();

	return viewer.run();
}
endsnippet

snippet osgNodeCallback
class ${1:MyUpdateCallback} : public osg::NodeCallback {
		virtual void operator()(osg::Node* node, osg::NodeVisitor* nv) {
			traverse(node,nv);
		}
};
endsnippet

snippet osgDrawCallback
class ${1:MyDrawableDrawCallback} : public osg::Drawable::DrawCallback {
		virtual void drawImplementation(osg::RenderInfo& renderInfo,const osg::Drawable* drawable) const {
			//pre draw implementation

			drawable->drawImplementation(renderInfo);

			//post draw Implementation

		}
};
endsnippet

snippet osgDrawableUpdateCallback
class ${1:MyDrawableUpdateCallback} : public osg::Drawable::UpdateCallback {
	virtual void update(osg::NodeVisitor* nv, osg::Drawable* drawable) {
	}
};
endsnippet

snippet osgDrawableCullCallback
class ${1:MyDrawableCullCallback} : public osg::Drawable::CullCallback {
	virtual bool cull(osg::NodeVisitor* nv, osg::Drawable* drawable, osg::State* state) const {
		return false;
	}
};
endsnippet

snippet osgReadFileCallback
class ${1:MyReadFileCallback} : public osgDB::Registry::ReadFileCallback {
public:
	virtual osgDB::ReaderWriter::ReadResult readNode(const std::string& fileName, const osgDB::ReaderWriter::Options* options) {
		// before readNode
		// note when calling the Registry to do the read you have to call readNodeImplementation NOT readNode, as this will
		// cause on infinite recusive loop.
		osgDB::ReaderWriter::ReadResult result = osgDB::Registry::instance()->readNodeImplementation(fileName,options);
		//after readNode
		return result;
	}
};
endsnippet

snippet osgGuiEventHandler
class ${1:MyGuiEventHandler} : public osgGA::GUIEventHandler {
	virtual bool handle(
		const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa) {
		switch (ea.getEventType()) {
			case osgGA::GUIEventAdapter::KEYDOWN:
				switch (ea.getKey()) {
					case osgGA::GUIEventAdapter::KEY_F1:
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}
		return false; //return true will stop event
	}
};
endsnippet

snippet osgObjectDescendent
	class ${1:Classname} : public osg::${2:Object} {
public:

	$1(){}
	$1(const $1& copy, const osg::CopyOp& copyop = osg::CopyOp::SHALLOW_COPY)
			: osg::$2(copy, copyop) {}
	~$1(){}
	META_${3:Object}(${4:zxd}, $1);
	};

endsnippet

snippet osgCreateGeometry
osg::ref_ptr<osg::Geometry> ${1:geometry} = new osg::Geometry;
osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array();
osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array();
colors->setBinding(osg::Array::BIND_OVERALL);

$1->setVertexArray(vertices);
$1->setColorArray(colors);

$1->addPrimitiveSet(new ${2:osg::DrawArrays(GL_POINTS, 0, 1)});

osg::StateSet* ss = $1->getOrCreateStateSet();
endsnippet

snippet osgCameraRayTest
osgUtil::IntersectionVisitor iv;
osg::ref_ptr<osgUtil::LineSegmentIntersector> lsi =
	new osgUtil::LineSegmentIntersector(
osgUtil::Intersector::WINDOW, ea.getX(), ea.getY());
iv.setIntersector(lsi);
//iv.setTraversalMask(selectMask);

camera->accept(iv);

if (lsi->containsIntersections()) {
	const osgUtil::LineSegmentIntersector::Intersection& result =
*lsi->getIntersections().begin();

} else {

}
endsnippet

snippet osgDecomposeMatrix
osg::Vec3 ${2:translation};
osg::Quat ${3:rotation};
osg::Vec3 ${4:scale};
osg::Quat ${5:so};
${1:m->}decompose($2, $3, $4, $5);
endsnippet

snippet osgCreateGraphicsContext
// create graphics context
osg::ref_ptr<osg::GraphicsContext::Traits> traits =
	new osg::GraphicsContext::Traits();

GLuint width = 800, height = 600;
osg::GraphicsContext::WindowingSystemInterface* wsi =
osg::GraphicsContext::getWindowingSystemInterface();
if (!wsi) OSG_FATAL << "failed to get window system interface " << std::endl;
wsi->getScreenResolution(
osg::GraphicsContext::ScreenIdentifier(0), width, height);

traits->x = 0;
traits->y = 0; // 0,0 is upper left , not lower left
traits->width = width;
traits->height = height;
traits->doubleBuffer = true;
traits->sharedContext = 0;
traits->windowDecoration = false;
//traits->alpha = 8;

osg::GraphicsContext* gc =
osg::GraphicsContext::createGraphicsContext(traits);
if (!gc) OSG_FATAL << "failed to creaate graphics context " << std::endl;
endsnippet

snippet osgGetCameraPerspective
//becareful fovy not in radian
double fovy, aspectRatio, zNear, zFar;
${1:camera}->getProjectionMatrixPerspective( fovy, aspectRatio, zNear, zFar);
endsnippet

snippet osgGetCameraFrustum
double left, right, bottom, top, near, far;
${1:camera}->getProjectionMatrixAsFrustum(
	left, right, bottom, top, near, far);
endsnippet

snippet osgGetCameraOrtho
double left, right, bottom, top, near, far;
${1:camera}->getProjectionMatrixAsOrtho(
	left, right, bottom, top, near, far);
endsnippet

snippet osgCreateAnimation
osg::ref_ptr<osgAnimation::BasicAnimationManager> manager =
	new osgAnimation::BasicAnimationManager;

osg::ref_ptr<osgAnimation::Animation> animation = new osgAnimation::Animation;
animation->setPlayMode(osgAnimation::Animation::${1:ONCE});

manager->registerAnimation(animation.get());

osg::ref_ptr<${2:osgAnimation::FloatLinearChannel}> ch = new $2;
ch->setName("${3:channelName}");
ch->setTargetName("${4:targetName}");
//populate channel data

animation->addChannel(ch.get());

osg::ref_ptr<osgAnimation::UpdateMatrixTransform> updater =
	new osgAnimation::UpdateMatrixTransform($4);
//populate updater element

endsnippet
